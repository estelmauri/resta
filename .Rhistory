k <- 6
# Calcular las permutaciones
permutaciones <- permutations(n, k, repeats.allowed = FALSE)
# Imprimir el número de permutaciones
print(length(permutaciones))
# Instalar el paquete combinat si no está instalado
if (!requireNamespace("combinat", quietly = TRUE)) {
install.packages("combinat")
}
# Cargar el paquete combinat
library(combinat)
# Instalar el paquete combinat si no está instalado
if (!requireNamespace("combinat", quietly = TRUE)) {
install.packages("combinat")
}
# Cargar el paquete combinat
library(combinat)
# Número total de objetos
n <- 10
# Número de objetos que deseas escoger
k <- 6
# Calcular las permutaciones sin repetición
permutaciones <- permn(n, k)
# Número total de objetos
n <- 10
# Número de objetos que deseas escoger
k <- 6
# Calcular las permutaciones sin repetición
permutaciones <- permn(n, k)
pnorm(145,135,2,lower.tail=FALSE)
qnorm(0,975,2,lower.tail=TRUE)
qnorm(0.975,2,lower.tail=TRUE)
qnorm(0,975,135,2,lower.tail=TRUE)
> qnorm(1,96,135,2,lower.tail=TRUE)
qnorm(1,96,135,2,lower.tail=TRUE)
qnorm(0.975,135,8,lower.tail=TRUE)
qnorm(0.975,135,4,lower.tail=TRUE)
qnorm(0.975,135,2,lower.tail=TRUE)
pchisq(70,19,ncp=0,lower.tail=TRUE)
# Datos del problema
n <- 20  # Tamaño de la muestra
varianza_poblacional <- 5^2  # Varianza poblacional (5 cm al cuadrado)
varianza_muestra <- 10  # Varianza de la muestra
# Grados de libertad
grados_de_libertad <- n - 1
# Calcular el valor chi-cuadrado
chi_cuadrado <- (n - 1) * varianza_muestra / varianza_poblacional
# Calcular la probabilidad usando la función pchisq
probabilidad <- pchisq(chi_cuadrado, df = grados_de_libertad)
# Imprimir la probabilidad
cat("La probabilidad de que la varianza de la muestra sea menor que 10 cm² es:", probabilidad, "\n")
pchisq(7.6,19,ncp=0,lower.tail = TRUE)
pchisq(10,19,ncp=0,lower.tail = TRUE)
# Imprimir la probabilidad
cat("La probabilidad de que la varianza de la muestra sea menor que 10 cm² es:", probabilidad, "\n")
# Calcular la probabilidad usando la función pchisq
probabilidad <- pchisq(chi_cuadrado, df = grados_de_libertad)
pnorm(145,135,2,lower.tail=FALSE)
pchisq(10,19,ncp=2,lower.tail = TRUE)
# Datos del problema
n <- 20  # Tamaño de la muestra
varianza_muestra <- 10  # Varianza de la muestra
varianza_poblacional <- 5^2  # Varianza poblacional (5 cm al cuadrado)
# Grados de libertad
grados_de_libertad <- n - 1
# Calcular el valor Z
Z <- (grados_de_libertad * varianza_muestra) / varianza_poblacional
# Calcular la probabilidad usando la función pchisq
probabilidad <- pchisq(Z, df = grados_de_libertad, lower.tail = TRUE)
# Imprimir la probabilidad
cat("La probabilidad de que la varianza de la muestra sea menor que 10 cm² es:", probabilidad, "\n")
-1,96*15,81
(-1,96)*15,81
(-1,96)*15,81
1,96*15,81
1.96*15,81
1.96*15.81
30.98+500
-30.98+500
pnorm(10,8,2,lowertail=TRUE)
pnorm(10,8,2,lowertail=TRUE)
pnorm(10,8,2,lower.tail=TRUE)
pnorm(10,8,2,lower.tail=FALSE)
pnorm(10,8,2,lower.tail=TRUE)
set.seed(123)
> n<-c(2,30,200,500)
set.seed(123)
> n<-c(2,30,200,500)
set.seed(123)
> n<-c(2,30,200,500)
> repli<-20
### ===========================================================
### Statistical Software: R and SAS, 29.9.2023
### Group B, R Lecture 4: Creation and manipulation of matrices
### ===========================================================
## Creation of matrices "by hand"
## Creation of matrices "by hand"
## ------------------------------
(A <- matrix(1:12, ncol = 4))
(AA <- matrix(1:12, nrow = 3, byrow = T))
class(A)
is.matrix(A)
attributes(A)
# Row and column numbers
dim(A)
nrow(A)
ncol(A)
# Another example
B <- matrix(-5:4, nc = 3)
B
dim(B)
t(B)
# Deconstruction of matrices (into a vector)
# ------------------------------------------
c(A)
as.vector(A)
## Creation of matrices using existing matrices or vectors
## -------------------------------------------------------
dim(A); dim(AA); dim(B)
cbind(A, AA) #combine by columns
rbind(A, AA) #combine by rows
cbind(A, AA) #combine by columns JOIN MATRIX ( COMBINE THE COLUMNS)
rbind(A, AA) #combine by rows
cbind(A, AA) #combine by columns JOIN MATRIX IM GOING TO ADD MORE VARIABLES SUMAME LAS COLUMNAS DE A Y LAS COLUMNAS DE AA PERO TENIENDO EN CUENTA LAS DIMENSIONES
cbind(A, B)              # Error!
cbind(A, B)              # Error!
cbind(A, B [-4])              # Error!
cbind(A, B [-4,])              # Error!
cbind(A, t(B))
# Let's now use the vectors stored in the R workspace GrB_RLecture4.RData
# -----------------------------------------------------------------------
# Our working directory
getwd()
# It's contents
dir()
# If it contains GrB_RLecture4.RData, then
load("GrB_RLecture4.RData")
# Let's now use the vectors stored in the R workspace GrB_RLecture4.RData
# -----------------------------------------------------------------------
# Our working directory
getwd()
# It's contents
dir()
# If it contains GrB_RLecture4.RData, then
load("GrB_RLecture4.RData")
# If not
setwd(...)
load("GrB_RLecture4.RData")
hwb <- cbind(hei, wei, bmi)
load("C:/Users/estel/Downloads/GrB_RLecture4.RData")
# Let's now use the vectors stored in the R workspace GrB_RLecture4.RData
# -----------------------------------------------------------------------
# Our working directory
getwd()
# It's contents
dir()
# If it contains GrB_RLecture4.RData, then
load("GrB_RLecture4.RData")
# If not
setwd(...)
# Let's now use the vectors stored in the R workspace GrB_RLecture4.RData
# -----------------------------------------------------------------------
# Our working directory
getwd()
# It's contents
dir()
# If it contains GrB_RLecture4.RData, then
load("GrB_RLecture4.RData")
# If not
setwd(...)
load("GrB_RLecture4.RData")
ls()
hwb <- cbind(hei, wei, bmi)
hwb
## Subsetting matrices
## -------------------
A[2, 3]
A[, 1] FIRST COLUMN
A[, 1] FIRST COLUMN
A[1, ] <- c(-3, 4, 0, 10)
hwb[c(1, 3), 2:3]
## Mathematical operations with matrices
## -------------------------------------
2*A
sqrt(A)
log(B)
A + AA
A*B               # R cannot handle that!
A*B               # R cannot handle that!
A*t(B)		      # Attention: This is NOT the matrix product
A[1, ] <- c(-3, 4, 0, 10)
log(B)
log(B)
## Mathematical operations with matrices
## -------------------------------------
2*A
A*B               # R cannot handle that!
A*t(B)		      # Attention: This is NOT the matrix product
# Matrix operations
(C <-A%*%B)    # This is the matrix product
diag(C)
det(C)
C^(-1)            # Attention: This is NOT the inverse matrix
# This is the inverse matrix
C %*% solve(C)
#BEST EXAMPLE
S <- matrix(data = c(5, 1, 1, 3), nrow = 2)
solve(S)
round(S %*% solve(S), 14)
# Statistical functions applied to matrices
# -----------------------------------------
sum(A)
mean(A)
median(B)
sd(B)
max(B)
# Position of the maximum
which.max(B)                      # Not so helpful
which(B == max(B))                # Neither
# Statistical functions that treat each column as a variable
var(hwb)
cov(hwb)
cor(hwb)                                 # Pearson
round(cor(hwb, method = "spearman"), 3)  # Spearman
summary(hwb)
colMeans(hwb)
colSums(hwb)
rowMeans(AA)
rowSums(AA)
# Little exercise: compute the correlation with missing values.
hwb[1:2, 1] <- hwb[19:20, 2] <- NA
# Statistical functions that treat each column as a variable
var(hwb)
cov(hwb)
cor(hwb)                                 # Pearson
round(cor(hwb, method = "spearman"), 3)  # Spearman
summary(hwb)
colMeans(hwb)
colSums(hwb)
rowMeans(AA)
rowSums(AA)
# Little exercise: compute the correlation with missing values.
hwb[1:2, 1] <- hwb[19:20, 2] <- NA
hwb
## All matrix elements are of the same type
## ----------------------------------------
cbind(hei, wei, prov)      # String matrix
## 3-dimensional arrays
## --------------------
D <- array(1:18, dim = c(2, 3, 3))
View(A)
View(A)
# Statistical functions that treat each column as a variable
var(hwb)
cor(hwb)                                 # Pearson
# Statistical functions that treat each column as a variable
var(hwb)
round(cor(hwb, method = "spearman"), 3)  # Spearman
colMeans(hwb)
summary(hwb)
colSums(hwb)
load("GrB_RLecture6.RData")
ls.str()
## Some useful functions to deal with missing values
## -------------------------------------------------
is.na(dfram2)
which(is.na(dfram2), arr.ind = T)
# Missings per variable
colSums(is.na(dfram2))
# ?Qu? variable tiene m?s missings (sabiendo que es una sola variable)?
which.max(colSums(is.na(dfram2)))
# ?Cu?ntos son?
max(colSums(is.na(dfram2)))
# Data frame containing only complete observations
na.omit(dfram2)
## Function fix permits to use the data editor
## -------------------------------------------
fix(dfram2)
load("GrB_RLecture6.RData")
# Function transform can also be used
transform(dfram1, Height = Height/100, BMI = round(Weight/(Height/100)^2, 2))
load("GrB_RLecture6.RData")
# Function transform can also be used
transform(dfram1, Height = Height/100, BMI = round(Weight/(Height/100)^2, 2))
### ===================================================================
### Statistical Software: R and SAS, 06.10.2023
### Group B, R Lecture 6: Creation of and working with data frames advanced (II)
### ===================================================================
load("GrB_RLecture6.RData")
## Subsetting data frames
## ----------------------
dfram23 <- subset(dfram1, Age == 23)
dfram23
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#absolute zero in Celsius
kelvin_to_celsius(0)
load("GrB_RLecture9.RData")
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#absolute zero in Celsius
kelvin_to_celsius(0)
load("GrB_RLecture9.RData")
## Function for
## ============
# Example 1
for (i in 1:5) {
print(i^(1:4))
}
#Now as a function:
function.for<-function(f){
for (i in 1:f) {
print(i^(1:4))
}
}
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#absolute zero in Celsius
kelvin_to_celsius(0)
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#absolute zero in Celsius
kelvin_to_celsius(0)
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#absolute zero in Celsius
kelvin_to_celsius(0)
load("GrB_RLecture9.RData")
setwd("C:/Users/estel/OneDrive/Escritorio/clase2310")
### ========================================================
### Statistical Software: R and SAS, 23.10.2023
### Group B, R Lecture 9: Control flow
### ========================================================
setwd("C:/Users/estel/OneDrive/Escritorio/clase2310")
#CREATE FUNCTIONS (see at: https://swcarpentry.github.io/swc-releases/2017.02/r-novice-inflammation/02-func-R/)
#defining a function fahr_to_kelvin that converts temperatures from Fahrenheit to Kelvin:
fahr_to_kelvin <- function(temp) {
kelvin <- ((temp - 32) * (5 / 9)) + 273.15
return(kelvin)
}
#Let's try running our function. Calling our own function is no different from calling any other function:
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
kelvin_to_celsius <- function(temp) {
celsius <- temp - 273.15
return(celsius)
}
#absolute zero in Celsius
kelvin_to_celsius(0)
load("GrB_RLecture9.RData")
load("GrB_RLecture9.RData")
## Function for
## ============
# Example 1
for (i in 1:5) {
print(i^(1:4))
}
library(usethis)
install.packages("usethis")
path <-file.path(C:\Users\estel\OneDrive\Escritorio\PAQUETE,"esteluski")
create_package(path)
library(usethis)
path <-file.path(C:\Users\estel\OneDrive\Escritorio\PAQUETE,"esteluski")
create_package(path)
setwd("~/")
setwd("C:/Users/estel/OneDrive/Escritorio/PAQUETE")
path <-file.path("C:/Users/estel/OneDrive/Escritorio/PAQUETE","esteluski")
create_package(path)
